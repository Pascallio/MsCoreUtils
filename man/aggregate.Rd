% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate.R, R/aggregate_by_matrix.R,
%   R/aggregate_by_vector.R
\name{aggregate}
\alias{aggregate}
\alias{aggregate_by_vector}
\alias{colMeansMat}
\alias{colSumsMat}
\alias{aggregate_by_matrix}
\title{Aggreagate quantitative features}
\usage{
colMeansMat(x, MAT)

colSumsMat(x, MAT)

aggregate_by_matrix(x, MAT, FUN, ...)

aggregate_by_vector(x, INDEX, FUN, ...)
}
\arguments{
\item{x}{A \code{matrix} of mode \code{numeric}.}

\item{MAT}{An adjacency matrix that defines what features with
\code{nrow(MAT) == nrow(x)}}

\item{FUN}{A \code{function} to be applied to the subsets of \code{x}.}

\item{...}{Additional arguments passed to \code{FUN}.}

\item{INDEX}{A \code{factor} of length \code{nrow(x)}.}
}
\value{
\code{\link[=aggregate_by_matrix]{aggregate_by_matrix()}} returns a \code{matrix} (or \code{Matrix})
of dimensions \code{ncol(MAT)} and \verb{ncol(x), with }dimnames\verb{equal to}colnames(x)\code{and}rownames(MAT)`.

\code{\link[=aggregate_by_vector]{aggregate_by_vector()}} returns a new \code{matrix} of
dimensions \code{length(INDEX)} and \verb{ncol(x), with }dimnames\verb{equal to}colnames(x)\code{and}INDEX`.
}
\description{
These functions takes a matrix of quantitative features \code{x} and
aggregates the features (rows) according to either a factor
\code{INDEX} or an adjacency matrix \code{MAT}. The aggregation function is
defined by a user-defined function \code{FUN}.

When aggregating by a vector/factor, the user-defined functions
must return a vector of length equal to \code{ncol(x)} for each level
in \code{INDEX}. Examples thereof are:
\itemize{
\item \code{\link[=medianPolish]{medianPolish()}} to fits an additive model (two way
decomposition) using Tukey's median polish_ procedure using
\code{\link[stats:medpolish]{stats::medpolish()}};
\item \code{\link[=robustSummary]{robustSummary()}} to calculate a robust aggregation using
\code{\link[MASS:rlm]{MASS::rlm()}};
\item \link[base:colSums]{base::colMeans()} to use the mean of each
column;
\item \code{\link[base:colSums]{base::colSums()}} to use the sum of each column;
\item \link[matrixStats:rowMedians]{matrixStats::colMedians()} to use
the median of each column.
}

When aggregating by an adjacency matrix, the user-defined
functions must return a new matrix. Examples thereof are:
\itemize{
\item \code{\link[=colSumsMat]{colSumsMat()}} aggregates by the summing the peptide intensities
for each protein. Shared peptides are re-used multiple times.
\item \code{\link[=colMeansMat]{colMeansMat()}} aggregation by the calculating the mean of
peptide intensities. Shared peptides are re-used multiple
times.
}
}
\examples{

x <- structure(c(10.3961935744407, 17.1663715212693, 14.1027587989326,
                12.850349037785, 10.6379251053134, 7.52885076885599,
                3.91816118984218, 11.1339832690524, 16.5321471730746,
                14.1787908569268, 11.9422579479634, 11.5154097311056,
                7.69906817878979, 3.97092153807337, 11.9394664781386,
                15.3791100898935, 14.2409281956285, 11.2106867261254,
                12.2958526883634, 9.00858488668671, 3.83120129974963,
                12.9033445520186, 14.375814954807, 14.1617803596661,
                10.1237981632645, 13.3390344671153, 9.75719265786117,
                3.81046169359919),
              .Dim = c(7L, 4L),
              .Dimnames = list(c("X1", "X27", "X41", "X47", "X52",
                                 "X53", "X55"),
                               c("iTRAQ4.114", "iTRAQ4.115",
                                 "iTRAQ4.116", "iTRAQ4.117")))
x

## -------------------------
## Aggregation by vector
## -------------------------

k <- factor(c("B", "E", "X", "E", "B", "B", "E"))

aggregate_by_vector(x, k, colMeans)
aggregate_by_vector(x, k, robustSummary)
aggregate_by_vector(x, k, medianPolish)


## -------------------------
## Aggregation by matrix
## -------------------------

library(Matrix)
adj <- sparseMatrix(i = c(1, 2, 3, 4, 4, 5, 6, 7, 7),
                    j = c(1, 2, 3, 1, 2, 1, 1, 2, 3),
                    x = 1)
colnames(adj) <- c("B", "E", "X")
rownames(adj) <- 1:7
adj

aggregate_by_matrix(x, adj, colSumsMat)
aggregate_by_matrix(x, adj, colMeansMat)
}
\seealso{
Other Quantitative feature aggregation: 
\code{\link{colCounts}()},
\code{\link{medianPolish}()},
\code{\link{robustSummary}()}
}
\author{
Laurent Gatto
}
\concept{Quantitative feature aggregation}
